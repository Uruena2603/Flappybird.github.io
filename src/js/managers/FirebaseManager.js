/**
 * Firebase Manager - Gesti√≥n profesional de Firebase
 * Maneja autenticaci√≥n, base de datos y sincronizaci√≥n
 *
 * @class FirebaseManager
 * @author Uruena2603
 * @version 1.0.0
 */

class FirebaseManager {
  constructor() {
    // Estado de Firebase
    this.app = null;
    this.db = null;
    this.auth = null;
    this.currentUser = null;
    this.isInitialized = false;
    this.isOnline = false;

    // Configuraci√≥n
    this.config = null;
    this.retryAttempts = 3;
    this.debugMode = false; // Para controlar logs excesivos

    // Estados de autenticaci√≥n
    this.authStates = {
      LOADING: "loading",
      ANONYMOUS: "anonymous",
      AUTHENTICATED: "authenticated",
      ERROR: "error",
    };

    this.currentAuthState = this.authStates.LOADING;

    // Callbacks para eventos
    this.onAuthStateChangedCallback = null;
    this.onConnectionStateChangedCallback = null;

    console.log("üî• FirebaseManager: Inicializado");
  }

  /**
   * Inicializar Firebase con configuraci√≥n
   * @param {Object} firebaseConfig - Configuraci√≥n de Firebase
   * @returns {Promise<boolean>} - true si se inicializ√≥ correctamente
   */
  async initialize(firebaseConfig) {
    try {
      console.log("üî• FirebaseManager: Iniciando configuraci√≥n...");

      // OPCIONAL: Detectar si estamos en localhost y mostrar aviso
      if (
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1"
      ) {
        console.warn(
          "üî• Firebase: Ejecutando en localhost - algunos features pueden tener limitaciones CORS"
        );
      }

      if (!firebaseConfig) {
        throw new Error("Configuraci√≥n de Firebase no proporcionada");
      }

      this.config = firebaseConfig;

      // Verificar que Firebase est√© disponible globalmente
      if (typeof firebase === "undefined") {
        throw new Error("Firebase SDK no est√° cargado");
      }

      // Inicializar Firebase App
      this.app = firebase.initializeApp(firebaseConfig);

      // Inicializar servicios
      this.auth = firebase.auth();
      this.db = firebase.firestore();

      // Configurar Firestore para offline
      this.db.enableNetwork();

      // NUEVO: Manejar resultados de redirect ANTES de configurar listeners
      await this.handleRedirectResult();

      // Configurar listeners de estado
      this.setupAuthStateListener();
      this.setupConnectionListener();

      // Inicializar usuario an√≥nimo autom√°ticamente (solo si no hay usuario)
      await this.initializeAnonymousUser();

      this.isInitialized = true;
      console.log("üî• FirebaseManager: ‚úÖ Configuraci√≥n completada");

      return true;
    } catch (error) {
      console.error("üî• FirebaseManager: ‚ùå Error inicializando:", error);
      this.currentAuthState = this.authStates.ERROR;
      return false;
    }
  }

  /**
   * Configurar listener de cambios de autenticaci√≥n (MEJORADO)
   * @private
   */
  setupAuthStateListener() {
    if (!this.auth) return;

    // CR√çTICO: Configurar persistencia ANTES de cualquier operaci√≥n
    this.auth
      .setPersistence(firebase.auth.Auth.Persistence.LOCAL)
      .then(() => {
        console.log(
          "üî• FirebaseManager: Persistencia configurada correctamente"
        );

        // IMPORTANTE: Verificar si ya hay un usuario persistente ANTES de crear an√≥nimo
        if (this.auth.currentUser && !this.auth.currentUser.isAnonymous) {
          console.log(
            "üî• FirebaseManager: Usuario persistente detectado en inicio"
          );
          return; // No crear usuario an√≥nimo
        }
      })
      .catch((error) => {
        console.warn(
          "üî• FirebaseManager: Error configurando persistencia:",
          error
        );
      });

    this.auth.onAuthStateChanged((user) => {
      console.log(
        "üî• FirebaseManager: Estado de auth cambi√≥:",
        user
          ? `${
              user.isAnonymous ? "an√≥nimo" : "registrado"
            } (${user.uid.substring(0, 8)}...)`
          : "no autenticado"
      );

      this.currentUser = user;

      if (user) {
        if (user.isAnonymous) {
          this.currentAuthState = this.authStates.ANONYMOUS;
          console.log("üî• FirebaseManager: Usuario an√≥nimo activo");
        } else {
          this.currentAuthState = this.authStates.AUTHENTICATED;
          console.log(
            "üî• FirebaseManager: Usuario registrado activo:",
            user.displayName || user.email || "Sin nombre"
          );
        }
      } else {
        this.currentAuthState = this.authStates.LOADING;
        console.log("üî• FirebaseManager: No hay usuario activo");
      }

      // Notificar cambio de estado
      if (this.onAuthStateChangedCallback) {
        this.onAuthStateChangedCallback(this.currentAuthState, user);
      }
    });
  }

  /**
   * Configurar listener de estado de conexi√≥n
   * @private
   */
  setupConnectionListener() {
    if (!this.db) return;

    // Para simplificar, solo verificamos si Firestore est√° disponible
    // En lugar de usar Realtime Database para detectar conexi√≥n
    this.isOnline = true; // Asumimos online por defecto
    console.log(`üî• FirebaseManager: Conexi√≥n üü¢ Online (Firestore ready)`);

    if (this.onConnectionStateChangedCallback) {
      this.onConnectionStateChangedCallback(this.isOnline);
    }
  }

  /**
   * Maneja resultados de redirect despu√©s de Google Auth (MEJORADO)
   * @private
   */
  async handleRedirectResult() {
    try {
      const result = await this.auth.getRedirectResult();

      if (result && result.user) {
        console.log(
          "üî• FirebaseManager: ‚úÖ Redirect exitoso:",
          result.user.email || "Usuario sin email"
        );

        // Limpiar flags de upgrade pendiente
        sessionStorage.removeItem("firebase_upgrade_pending");
        sessionStorage.removeItem("firebase_anonymous_uid");

        // Verificar si era un upgrade de usuario an√≥nimo
        const wasUpgrade =
          sessionStorage.getItem("firebase_upgrade_pending") === "true";
        if (wasUpgrade) {
          console.log(
            "üî• FirebaseManager: ‚úÖ Upgrade de an√≥nimo a permanente completado"
          );
        }

        return true;
      }

      // Verificar si hab√≠a un upgrade pendiente que no se complet√≥
      const upgradePending = sessionStorage.getItem("firebase_upgrade_pending");
      if (upgradePending) {
        console.log("üî• FirebaseManager: ‚ö†Ô∏è Upgrade pendiente no completado");
        sessionStorage.removeItem("firebase_upgrade_pending");
        sessionStorage.removeItem("firebase_anonymous_uid");
      }

      return false;
    } catch (error) {
      console.warn(
        "üî• FirebaseManager: Error manejando redirect result:",
        error
      );

      // Limpiar flags en caso de error
      sessionStorage.removeItem("firebase_upgrade_pending");
      sessionStorage.removeItem("firebase_anonymous_uid");

      return false;
    }
  }

  /**
   * Inicializar usuario an√≥nimo autom√°ticamente (MEJORADO)
   * @private
   */
  async initializeAnonymousUser() {
    try {
      // IMPORTANTE: Solo crear an√≥nimo si NO hay usuario actual
      if (this.auth.currentUser) {
        console.log(
          "üî• FirebaseManager: Usuario ya existe, no creando an√≥nimo"
        );
        console.log("üî• FirebaseManager: Usuario actual:", {
          uid: this.auth.currentUser.uid.substring(0, 8) + "...",
          isAnonymous: this.auth.currentUser.isAnonymous,
          email: this.auth.currentUser.email,
        });
        return this.auth.currentUser;
      }

      console.log("üî• FirebaseManager: No hay usuario, creando an√≥nimo...");
      const result = await this.auth.signInAnonymously();
      console.log(
        "üî• FirebaseManager: ‚úÖ Usuario an√≥nimo creado:",
        result.user.uid.substring(0, 8) + "..."
      );
      return result.user;
    } catch (error) {
      console.warn(
        "üî• FirebaseManager: ‚ö†Ô∏è Error creando usuario an√≥nimo:",
        error
      );
      return null;
    }
  }

  // =========================
  // M√âTODOS DE AUTENTICACI√ìN
  // =========================

  /**
   * Verificar si hay un usuario autenticado
   * @returns {boolean}
   */
  isUserAuthenticated() {
    return this.currentAuthState === this.authStates.AUTHENTICATED;
  }

  /**
   * Verificar si el usuario actual es an√≥nimo
   * @returns {boolean}
   */
  isUserAnonymous() {
    return this.currentAuthState === this.authStates.ANONYMOUS;
  }

  /**
   * Obtener informaci√≥n del usuario actual
   * @returns {Object|null}
   */
  getCurrentUser() {
    return this.currentUser;
  }

  /**
   * Obtener nombre para mostrar del usuario
   * @returns {string}
   */
  getUserDisplayName() {
    if (!this.currentUser) return "Invitado";

    if (this.currentUser.isAnonymous) {
      return "Jugador An√≥nimo";
    }

    return this.currentUser.displayName || this.currentUser.email || "Usuario";
  }

  /**
   * Obtener UID √∫nico del usuario
   * @returns {string|null}
   */
  getUserId() {
    return this.currentUser ? this.currentUser.uid : null;
  }

  /**
   * Convierte usuario an√≥nimo a cuenta permanente con Google (SOLUCIONADO CORS)
   * @returns {Promise<boolean>} - true si fue exitoso
   */
  async upgradeAnonymousToGoogle() {
    try {
      // Verificar si ya est√° registrado permanentemente
      if (this.isUserPermanentlyRegistered()) {
        console.log(
          "üî• FirebaseManager: Usuario ya registrado permanentemente"
        );
        return true;
      }

      console.log("üî• FirebaseManager: Iniciando upgrade a Google...");

      // Crear proveedor de Google
      const provider = new firebase.auth.GoogleAuthProvider();
      provider.addScope("email");
      provider.addScope("profile");

      // NUEVA ESTRATEGIA: Detectar entorno de producci√≥n vs desarrollo
      const isProduction =
        window.location.hostname !== "localhost" &&
        window.location.hostname !== "127.0.0.1";

      if (this.isUserAnonymous() && this.auth.currentUser) {
        try {
          console.log(
            "üî• FirebaseManager: Intentando upgrade de usuario an√≥nimo..."
          );

          if (isProduction) {
            // EN PRODUCCI√ìN: Usar signInWithRedirect directamente para evitar CORS
            console.log(
              "üî• FirebaseManager: Producci√≥n detectada - usando redirect..."
            );

            // Guardar estado del usuario an√≥nimo antes del redirect
            sessionStorage.setItem("firebase_upgrade_pending", "true");
            sessionStorage.setItem(
              "firebase_anonymous_uid",
              this.auth.currentUser.uid
            );

            // Usar redirect en producci√≥n (m√°s confiable)
            await this.auth.currentUser.linkWithRedirect(provider);
            return true; // El resultado se manejar√° despu√©s del redirect
          } else {
            // EN DESARROLLO: Intentar popup primero
            console.log("üî• FirebaseManager: Desarrollo - intentando popup...");
            const result = await this.auth.currentUser.linkWithPopup(provider);
            console.log("üî• FirebaseManager: ‚úÖ Link con popup exitoso");
            return true;
          }
        } catch (linkError) {
          console.log(
            "üî• FirebaseManager: Error en link, intentando manejo inteligente:",
            linkError.code
          );

          // Si el error es que la cuenta ya existe, hacer login directo
          if (linkError.code === "auth/credential-already-in-use") {
            return await this.handleExistingAccountLogin(provider);
          }

          // Para otros errores en producci√≥n, usar redirect
          if (isProduction) {
            console.log(
              "üî• FirebaseManager: Fallback a redirect en producci√≥n..."
            );
            await this.auth.signInWithRedirect(provider);
            return true;
          }

          throw linkError;
        }
      }

      // Usuario no an√≥nimo - hacer login directo
      console.log("üî• FirebaseManager: Haciendo login directo...");

      if (isProduction) {
        // En producci√≥n, usar redirect para login directo tambi√©n
        await this.auth.signInWithRedirect(provider);
        return true;
      } else {
        // En desarrollo, usar popup
        const result = await this.auth.signInWithPopup(provider);
        console.log("üî• FirebaseManager: ‚úÖ Login directo exitoso");
        return true;
      }
    } catch (error) {
      console.error("üî• FirebaseManager: ‚ùå Error en upgrade:", error);
      return await this.handleAuthError(error);
    }
  }

  /**
   * Maneja login cuando la cuenta ya existe (NUEVO)
   * @private
   */
  async handleExistingAccountLogin(provider) {
    try {
      console.log(
        "üî• FirebaseManager: Cuenta existente detectada - haciendo login directo..."
      );

      const isProduction =
        window.location.hostname !== "localhost" &&
        window.location.hostname !== "127.0.0.1";

      if (isProduction) {
        // En producci√≥n usar redirect
        await this.auth.signInWithRedirect(provider);
        return true;
      } else {
        // En desarrollo usar popup
        const result = await this.auth.signInWithPopup(provider);
        console.log("üî• FirebaseManager: ‚úÖ Login de cuenta existente exitoso");
        return true;
      }
    } catch (error) {
      console.error(
        "üî• FirebaseManager: Error en login de cuenta existente:",
        error
      );
      throw error;
    }
  }

  /**
   * Maneja errores de autenticaci√≥n de manera inteligente
   * @param {Error} error - Error de Firebase Auth
   * @returns {Promise<boolean>}
   */
  async handleAuthError(error) {
    console.log("üî• FirebaseManager: Manejando error de auth:", error.code);

    const isProduction =
      window.location.hostname !== "localhost" &&
      window.location.hostname !== "127.0.0.1";

    try {
      switch (error.code) {
        case "auth/credential-already-in-use":
          // La cuenta ya existe - hacer login directo
          console.log(
            "üî• FirebaseManager: Detectada cuenta existente, haciendo login directo..."
          );
          const provider = new firebase.auth.GoogleAuthProvider();
          return await this.handleExistingAccountLogin(provider);

        case "auth/popup-blocked":
        case "auth/popup-closed-by-user":
        case "auth/cancelled-popup-request":
          if (isProduction) {
            console.log(
              "üî• FirebaseManager: Error de popup en producci√≥n - usando redirect..."
            );
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope("email");
            provider.addScope("profile");
            await this.auth.signInWithRedirect(provider);
            return true;
          } else {
            throw new Error(
              "Por favor, permite los popups en tu navegador para completar el registro"
            );
          }

        case "auth/network-request-failed":
          throw new Error(
            "Error de conexi√≥n. Verifica tu internet e int√©ntalo de nuevo"
          );

        case "auth/too-many-requests":
          throw new Error(
            "Demasiados intentos. Espera un momento e int√©ntalo de nuevo"
          );

        default:
          console.error("üî• FirebaseManager: Error no manejado:", error.code);

          if (isProduction) {
            // En producci√≥n, siempre ofrecer redirect como fallback
            console.log(
              "üî• FirebaseManager: Fallback a redirect para error no manejado..."
            );
            const provider = new firebase.auth.GoogleAuthProvider();
            provider.addScope("email");
            provider.addScope("profile");
            await this.auth.signInWithRedirect(provider);
            return true;
          } else {
            throw new Error(
              "Error en el registro. Por favor, int√©ntalo de nuevo m√°s tarde"
            );
          }
      }
    } catch (handleError) {
      console.error(
        "üî• FirebaseManager: Error en manejo de error:",
        handleError
      );
      throw handleError;
    }
  }

  /**
   * Crear cuenta nueva con Google (para uso futuro)
   * @returns {Promise<boolean>}
   */
  async signInWithGoogle() {
    try {
      console.log("üî• FirebaseManager: Iniciando login con Google...");

      const provider = new firebase.auth.GoogleAuthProvider();
      provider.addScope("email");
      provider.addScope("profile");

      const result = await this.auth.signInWithPopup(provider);

      console.log(
        "üî• FirebaseManager: ‚úÖ Login exitoso:",
        result.user.displayName
      );
      return true;
    } catch (error) {
      console.error("üî• FirebaseManager: ‚ùå Error en login:", error);
      return false;
    }
  }

  /**
   * Verificar si hay un usuario permanentemente registrado (OPTIMIZADO)
   * @returns {boolean}
   */
  isUserPermanentlyRegistered() {
    if (!this.currentUser) {
      return false;
    }

    const isPermanent =
      !this.currentUser.isAnonymous &&
      this.currentUser.providerData &&
      this.currentUser.providerData.length > 0;

    // CORREGIDO: Solo log en debug mode para evitar spam
    if (this.debugMode) {
      console.log("üî• FirebaseManager: Usuario permanente?", isPermanent);
      console.log(
        "üî• FirebaseManager: isAnonymous:",
        this.currentUser.isAnonymous
      );
      console.log(
        "üî• FirebaseManager: providerData length:",
        this.currentUser.providerData?.length || 0
      );
    }

    return isPermanent;
  }

  /**
   * Obtener informaci√≥n completa del usuario (SIN LOGS EXCESIVOS)
   * @returns {Object|null}
   */
  getUserInfo() {
    if (!this.currentUser) {
      return null;
    }

    const userInfo = {
      uid: this.currentUser.uid,
      isAnonymous: this.currentUser.isAnonymous,
      displayName: this.currentUser.displayName,
      email: this.currentUser.email,
      photoURL: this.currentUser.photoURL,
      providerData: this.currentUser.providerData,
      isPermanent: this.isUserPermanentlyRegistered(),
    };

    // CORREGIDO: Solo log cuando se solicita expl√≠citamente
    if (this.debugMode) {
      console.log("üî• FirebaseManager: Info de usuario obtenida:", {
        uid: userInfo.uid,
        isAnonymous: userInfo.isAnonymous,
        displayName: userInfo.displayName,
        email: userInfo.email,
        isPermanent: userInfo.isPermanent,
        providers: userInfo.providerData?.map((p) => p.providerId) || [],
      });
    }

    return userInfo;
  }

  // =======================
  // M√âTODOS DE BASE DE DATOS
  // =======================

  /**
   * Verificar si Firebase est√° listo para usar
   * @returns {boolean}
   */
  isReady() {
    return this.isInitialized && this.auth && this.db && this.currentUser;
  }

  /**
   * Obtener referencia de colecci√≥n
   * @param {string} collectionName - Nombre de la colecci√≥n
   * @returns {firebase.firestore.CollectionReference|null}
   */
  getCollection(collectionName) {
    if (!this.isReady()) {
      console.warn("üî• FirebaseManager: No est√° listo para operaciones de DB");
      return null;
    }
    return this.db.collection(collectionName);
  }

  /**
   * Configurar nickname personalizado del usuario
   * @param {string} nickname - Nickname elegido por el usuario
   * @returns {Promise<boolean>}
   */
  async setUserNickname(nickname) {
    try {
      if (!this.isReady() || !this.currentUser) {
        console.error("üî• FirebaseManager: No listo para configurar nickname");
        return false;
      }

      // Validar nickname
      if (!nickname || typeof nickname !== "string") {
        throw new Error("El nickname debe ser un texto v√°lido");
      }

      const cleanNickname = nickname.trim();

      if (cleanNickname.length < 2 || cleanNickname.length > 20) {
        throw new Error("El nickname debe tener entre 2 y 20 caracteres");
      }

      // Guardar en Firestore
      await this.db.collection("users").doc(this.currentUser.uid).set(
        {
          nickname: cleanNickname,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          userId: this.currentUser.uid,
          email: this.currentUser.email,
          displayName: this.currentUser.displayName,
        },
        { merge: true }
      );

      console.log(
        "üî• FirebaseManager: ‚úÖ Nickname configurado:",
        cleanNickname
      );
      return true;
    } catch (error) {
      console.error(
        "üî• FirebaseManager: ‚ùå Error configurando nickname:",
        error
      );
      throw error;
    }
  }

  /**
   * Obtener nickname del usuario (o generar uno por defecto)
   * @returns {Promise<string>}
   */
  async getUserNickname() {
    try {
      if (!this.isReady() || !this.currentUser) {
        console.log("üî• FirebaseManager: No listo para obtener nickname");
        return "Jugador An√≥nimo";
      }

      if (this.currentUser.isAnonymous) {
        return "Jugador An√≥nimo";
      }

      // Intentar obtener de Firestore
      const userDoc = await this.db
        .collection("users")
        .doc(this.currentUser.uid)
        .get();

      if (userDoc.exists && userDoc.data().nickname) {
        const nickname = userDoc.data().nickname;
        console.log(
          "üî• FirebaseManager: Nickname obtenido de Firestore:",
          nickname
        );
        return nickname;
      }

      // Fallback a nombre de Google
      const fallbackName =
        this.currentUser.displayName ||
        this.currentUser.email?.split("@")[0] ||
        "Usuario";

      console.log(
        "üî• FirebaseManager: Usando nickname por defecto:",
        fallbackName
      );
      return fallbackName;
    } catch (error) {
      console.warn("üî• FirebaseManager: Error obteniendo nickname:", error);
      return (
        this.currentUser?.displayName ||
        this.currentUser?.email?.split("@")[0] ||
        "Usuario"
      );
    }
  }

  // ================
  // M√âTODOS UTILITARIOS
  // ================

  /**
   * Configurar callback para cambios de autenticaci√≥n
   * @param {Function} callback
   */
  onAuthStateChanged(callback) {
    this.onAuthStateChangedCallback = callback;
  }

  /**
   * Configurar callback para cambios de conexi√≥n
   * @param {Function} callback
   */
  onConnectionStateChanged(callback) {
    this.onConnectionStateChangedCallback = callback;
  }

  /**
   * Obtener estado completo para debug
   * @returns {Object}
   */
  getDebugInfo() {
    return {
      initialized: this.isInitialized,
      online: this.isOnline,
      authState: this.currentAuthState,
      userId: this.getUserId(),
      displayName: this.getUserDisplayName(),
      isAnonymous: this.isUserAnonymous(),
      isAuthenticated: this.isUserAuthenticated(),
      ready: this.isReady(),
    };
  }

  /**
   * Limpiar recursos y listeners
   */
  cleanup() {
    console.log("üî• FirebaseManager: Limpiando recursos...");

    if (this.auth) {
      // Remover listeners si es necesario
    }

    this.onAuthStateChangedCallback = null;
    this.onConnectionStateChangedCallback = null;

    console.log("üî• FirebaseManager: ‚úÖ Recursos limpiados");
  }
  /**
   * Verificar si un nickname ya existe
   * @param {string} nickname
   * @returns {Promise<boolean>}
   */
  async checkNicknameExists(nickname) {
    try {
      if (!this.isReady()) return false;

      const snapshot = await this.db
        .collection("users")
        .where("nickname", "==", nickname.trim())
        .limit(1)
        .get();

      return !snapshot.empty;
    } catch (error) {
      console.warn("üî• FirebaseManager: Error verificando nickname:", error);
      return false; // En caso de error, permitir el nickname
    }
  }

  /**
   * Configurar nickname personalizado del usuario (MEJORADO CON VALIDACI√ìN)
   * @param {string} nickname - Nickname elegido por el usuario
   * @returns {Promise<boolean>}
   */
  async setUserNickname(nickname) {
    try {
      if (
        !this.isReady() ||
        !this.currentUser ||
        this.currentUser.isAnonymous
      ) {
        throw new Error("Usuario no v√°lido para configurar nickname");
      }

      // Validar nickname
      const cleanNickname = nickname.trim();
      if (
        !cleanNickname ||
        cleanNickname.length < 2 ||
        cleanNickname.length > 20
      ) {
        throw new Error("El nickname debe tener entre 2 y 20 caracteres");
      }

      // Verificar caracteres v√°lidos (letras, n√∫meros, espacios, guiones)
      const validChars = /^[a-zA-Z0-9\s\-_]+$/;
      if (!validChars.test(cleanNickname)) {
        throw new Error(
          "El nickname solo puede contener letras, n√∫meros, espacios y guiones"
        );
      }

      // Verificar si el nickname ya existe
      const nicknameExists = await this.checkNicknameExists(cleanNickname);
      if (nicknameExists) {
        throw new Error("Este nickname ya est√° en uso, elige otro");
      }

      // Guardar en Firestore
      await this.db.collection("users").doc(this.currentUser.uid).set(
        {
          nickname: cleanNickname,
          email: this.currentUser.email,
          displayName: this.currentUser.displayName,
          photoURL: this.currentUser.photoURL,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
        },
        { merge: true }
      );

      console.log(
        "üî• FirebaseManager: ‚úÖ Nickname configurado:",
        cleanNickname
      );
      return true;
    } catch (error) {
      console.error(
        "üî• FirebaseManager: ‚ùå Error configurando nickname:",
        error
      );
      throw error;
    }
  }

  /**
   * Obtener nickname del usuario actual (MEJORADO)
   * @returns {Promise<string>}
   */
  async getUserNickname() {
    try {
      if (!this.isReady() || !this.currentUser) return "Jugador An√≥nimo";

      if (this.currentUser.isAnonymous) return "Jugador An√≥nimo";

      // Intentar obtener de Firestore primero
      const userDoc = await this.db
        .collection("users")
        .doc(this.currentUser.uid)
        .get();

      if (userDoc.exists && userDoc.data().nickname) {
        return userDoc.data().nickname;
      }

      // Fallback: usar displayName de Google o email
      return (
        this.currentUser.displayName ||
        this.currentUser.email?.split("@")[0] ||
        "Usuario"
      );
    } catch (error) {
      console.warn("üî• FirebaseManager: Error obteniendo nickname:", error);
      return this.currentUser?.displayName || "Usuario";
    }
  }

  /**
   * Verificar si el usuario necesita configurar nickname personalizado
   * @returns {Promise<boolean>}
   */
  async needsNicknameSetup() {
    try {
      if (
        !this.isReady() ||
        !this.currentUser ||
        this.currentUser.isAnonymous
      ) {
        return false;
      }

      const userDoc = await this.db
        .collection("users")
        .doc(this.currentUser.uid)
        .get();

      // Si no existe documento o no tiene nickname personalizado
      if (!userDoc.exists || !userDoc.data().nickname) {
        return true;
      }

      const nickname = userDoc.data().nickname;

      // Si el nickname es igual al displayName o email, necesita personalizaci√≥n
      return (
        nickname === this.currentUser.displayName ||
        nickname === this.currentUser.email?.split("@")[0]
      );
    } catch (error) {
      console.warn(
        "üî• FirebaseManager: Error verificando necesidad de nickname:",
        error
      );
      return false;
    }
  }

  // ==================== LEADERBOARD SYSTEM ====================

  /**
   * Guarda puntuaci√≥n en el leaderboard global con nueva arquitectura separada
   * NUEVA L√ìGICA: Siempre guarda en game_sessions, solo actualiza leaderboard si es record
   * @param {number} score - Puntuaci√≥n obtenida
   * @param {number} level - Nivel alcanzado
   * @param {number} gameTime - Tiempo de juego en segundos
   * @param {Object} gameStats - Estad√≠sticas adicionales del juego
   * @returns {Promise<boolean>}
   */
  async saveScore(score, level, gameTime, gameStats = {}) {
    try {
      // Verificaciones de seguridad mejoradas
      if (!this.isReady()) {
        console.warn("üî• FirebaseManager: No est√° listo para guardar score");
        return false;
      }

      if (!this.currentUser) {
        console.warn("üî• FirebaseManager: No hay usuario autenticado");
        return false;
      }

      if (this.currentUser.isAnonymous) {
        console.log("üî• FirebaseManager: Usuario an√≥nimo - no se guarda score en leaderboard");
        return false;
      }

      console.log(
        `üî• FirebaseManager: Guardando score - Score: ${score}, Level: ${level}, Time: ${gameTime}s`
      );

      const userNickname = await this.getUserNickname();
      const userId = this.currentUser.uid;

      // Datos completos del score para el leaderboard global
      const scoreData = {
        userId: userId,
        nickname: userNickname,
        email: this.currentUser.email,
        score: score,
        level: level,
        gameTime: gameTime,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),

        // Estad√≠sticas adicionales
        totalJumps: gameStats.totalJumps || 0,
        pipesPassedCount: Math.floor(score), // pipes pasados = score
        accuracy: gameStats.accuracy || 0,
        maxHeight: gameStats.maxHeight || 0,

        // Metadatos
        gameVersion: "2.0.0",
        platform: this.getBrowserInfo(),
        deviceType: this.getDeviceType(),
        userAgent: navigator.userAgent,
      };

      // üéØ USAR BATCH OPERATIONS PARA OPERACIONES AT√ìMICAS
      console.log("üî• FirebaseManager: Iniciando operaciones batch...");
      const batch = this.db.batch();

      // 1. Guardar en leaderboard global
      const scoreRef = this.db.collection("leaderboard_scores").doc();
      batch.set(scoreRef, scoreData);
      console.log("üî• FirebaseManager: Agregado al batch - leaderboard global");

      // 2. Guardar en historial personal del usuario
      console.log("üî• FirebaseManager: Guardando en historial de partidas...");
      const gameHistoryRef = this.db
        .collection("user_game_history")
        .doc(userId)
        .collection("games")
        .doc();
      
      batch.set(gameHistoryRef, {
        ...scoreData,
        gameId: gameHistoryRef.id,
      });
      console.log("üî• FirebaseManager: Agregado al batch - historial personal");

      // 3. Actualizar estad√≠sticas personales del usuario
      const userStatsRef = this.db.collection("user_stats").doc(userId);
      batch.set(userStatsRef, {
        userId: userId,
        nickname: userNickname,
        email: this.currentUser.email,
        totalGames: firebase.firestore.FieldValue.increment(1),
        bestScore: score, // Se actualizar√° con el m√°ximo en el servidor
        totalPlayTime: firebase.firestore.FieldValue.increment(gameTime),
        lastPlayed: firebase.firestore.FieldValue.serverTimestamp(),
        averageScore: score, // Se calcular√° correctamente en el servidor
        level: level,
      }, { merge: true });
      console.log("üî• FirebaseManager: Agregado al batch - estad√≠sticas personales");

      // Ejecutar todas las operaciones de forma at√≥mica
      await batch.commit();
      
      console.log("üî• FirebaseManager: ‚úÖ Score guardado exitosamente con batch operations");
      return true;

    } catch (error) {
      console.error("üî• FirebaseManager: ‚ùå Error guardando score:", error);
      
      // Diagn√≥stico detallado mejorado
      if (error.code === "permission-denied") {
        console.error("üö® Error de permisos - Verificar reglas de Firestore:");
        console.error("   - ¬øLas reglas est√°n publicadas?");
        console.error(`   - ¬øEl usuario est√° autenticado? ${!!this.currentUser}`);
        console.error(`   - ¬øUsuario an√≥nimo? ${this.currentUser?.isAnonymous}`);
        console.error(`   - UID del usuario: ${this.currentUser?.uid}`);
        console.error(`   - Email del usuario: ${this.currentUser?.email}`);
        console.error("   - Verifica que las reglas permitan escritura para usuarios registrados");
      } else {
        console.error("   - Tipo de error:", error.code);
        console.error("   - Mensaje:", error.message);
      }
      
      return false;
    }
  }

  /**
   * üéØ NUEVO M√âTODO: Verifica si es record personal y actualiza leaderboard
   * @param {string} userId - ID del usuario
   * @param {string} nickname - Nickname del usuario
   * @param {number} score - Score actual
   * @param {number} level - Nivel actual
   * @param {number} gameTime - Tiempo de juego
   * @param {Object} gameSessionData - Datos completos de la sesi√≥n
   * @returns {Promise<boolean>} - true si se actualiz√≥ el leaderboard
   */
  async checkAndUpdateLeaderboard(
    userId,
    nickname,
    score,
    level,
    gameTime,
    gameSessionData
  ) {
    try {
      // Obtener record actual del usuario
      const currentRecordQuery = await this.db
        .collection("leaderboard")
        .where("userId", "==", userId)
        .limit(1)
        .get();

      const leaderboardData = {
        userId: userId,
        nickname: nickname,
        email: gameSessionData.email,
        score: score,
        level: level,
        gameTime: gameTime,
        lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),

        // Mantener mejores estad√≠sticas
        totalJumps: gameSessionData.totalJumps,
        pipesPassedCount: gameSessionData.pipesPassedCount,
        accuracy: gameSessionData.accuracy,
        maxHeight: gameSessionData.maxHeight,

        // Metadatos
        gameVersion: gameSessionData.gameVersion,
        platform: gameSessionData.platform,
        deviceType: gameSessionData.deviceType,
      };

      if (currentRecordQuery.empty) {
        // üÜï PRIMER RECORD: Crear entrada nueva en leaderboard
        console.log(
          "üî• FirebaseManager: Primer record del usuario, creando entrada en leaderboard"
        );

        const newRecordRef = await this.db
          .collection("leaderboard")
          .add(leaderboardData);

        console.log(
          "ÔøΩ FirebaseManager: ‚úÖ Nueva entrada de leaderboard creada:",
          newRecordRef.id
        );
        return true;
      } else {
        // üîÑ VERIFICAR SI SUPERA RECORD ACTUAL
        const currentRecord = currentRecordQuery.docs[0];
        const currentBestScore = currentRecord.data().score || 0;

        if (score > currentBestScore) {
          console.log(
            `üî• FirebaseManager: ¬°Nuevo record! ${score} > ${currentBestScore}`
          );

          // Actualizar record existente
          await currentRecord.ref.update(leaderboardData);

          console.log(
            "üî• FirebaseManager: ‚úÖ Record de leaderboard actualizado"
          );
          return true;
        } else {
          console.log(
            `üî• FirebaseManager: Score ${score} no supera record actual ${currentBestScore}`
          );
          return false;
        }
      }
    } catch (error) {
      console.error(
        "üî• FirebaseManager: ‚ùå Error verificando/actualizando leaderboard:",
        error
      );
      return false;
    }
  }

  /**
   * Obtiene el leaderboard global (MEJORADO CON FALLBACK)
   * @param {number} limit - N√∫mero m√°ximo de resultados
   * @returns {Promise<Array>}
   */
  async getGlobalLeaderboard(limit = 10) {
    try {
      // Verificaciones de seguridad mejoradas
      if (!this.isReady()) {
        console.warn(
          "üî• FirebaseManager: Firebase no est√° listo para obtener leaderboard"
        );
        return [];
      }

      console.log(
        `üî• FirebaseManager: Obteniendo leaderboard global (top ${limit})...`
      );

      // Usar la nueva colecci√≥n leaderboard_scores con mejores consultas
      let snapshot;
      try {
        console.log("üî• FirebaseManager: Intentando consulta con √≠ndice compuesto...");
        snapshot = await this.db
          .collection("leaderboard_scores")
          .orderBy("score", "desc")
          .orderBy("timestamp", "asc") // En caso de empate, el m√°s antiguo primero
          .limit(limit)
          .get();
          
        console.log(`üî• FirebaseManager: ‚úÖ Consulta exitosa con ${snapshot.docs.length} resultados`);
      } catch (indexError) {
        if (indexError.message?.includes("index") || indexError.code === "failed-precondition") {
          console.warn(
            "üî• FirebaseManager: ‚ö†Ô∏è √çndices no listos - usando consulta simple por score"
          );
          // Fallback: solo orderBy score
          snapshot = await this.db
            .collection("leaderboard_scores")
            .orderBy("score", "desc")
            .limit(limit)
            .get();
            
          console.log(`üî• FirebaseManager: ‚úÖ Consulta fallback exitosa con ${snapshot.docs.length} resultados`);
        } else {
          throw indexError;
        }
      }

      // Procesar los resultados con mejor manejo de datos
      const leaderboard = snapshot.docs.map((doc, index) => {
        const data = doc.data();
        return {
          rank: index + 1,
          id: doc.id,
          nickname: data.nickname || "Jugador An√≥nimo",
          score: data.score || 0,
          level: data.level || 1,
          gameTime: data.gameTime || 0,
          timestamp: data.timestamp?.toDate?.() || null,
          totalJumps: data.totalJumps || 0,
          accuracy: data.accuracy || 0,
          maxHeight: data.maxHeight || 0,
          platform: data.platform || "Unknown",
          deviceType: data.deviceType || "Unknown",
          gameVersion: data.gameVersion || "1.0.0",
          isCurrentUser: data.userId === this.currentUser?.uid,
        };
      });

      console.log(
        `üî• FirebaseManager: ‚úÖ Leaderboard obtenido (${leaderboard.length} records)`
      );
      
      // Log adicional para debugging
      if (leaderboard.length > 0) {
        console.log(`üî• Top score: ${leaderboard[0].nickname} - ${leaderboard[0].score} puntos`);
      }
      
      return leaderboard;

    } catch (error) {
      console.error(
        "üî• FirebaseManager: ‚ùå Error obteniendo leaderboard:",
        error
      );

      // Diagn√≥stico detallado mejorado
      if (error.code === "permission-denied") {
        console.error("üö® Error de permisos en leaderboard - Verificar:");
        console.error("   - ¬øLas reglas permiten lectura de 'leaderboard_scores'?");
        console.error(`   - ¬øUsuario autenticado? ${!!this.currentUser}`);
        console.error(`   - ¬øUsuario an√≥nimo? ${this.currentUser?.isAnonymous}`);
        console.error("   - Verifica que las reglas Firestore est√©n publicadas");
      } else if (error.message?.includes("index") || error.code === "failed-precondition") {
        console.error("üö® SOLUCI√ìN para √≠ndices faltantes:");
        console.error("   1. Ve a Firebase Console ‚Üí Firestore ‚Üí Indexes");
        console.error("   2. Crea √≠ndice compuesto: leaderboard_scores");
        console.error("      - Campo 1: score (Descending)");
        console.error("      - Campo 2: timestamp (Ascending)");
        console.error("   3. O usar el enlace autom√°tico que aparece en la consola de Firebase");
        console.error("   4. Los √≠ndices pueden tardar unos minutos en estar listos");
      } else if (error.code === "unavailable") {
        console.error("üö® Firebase temporalmente no disponible - reintentar m√°s tarde");
      } else {
        console.error("   - C√≥digo de error:", error.code);
        console.error("   - Mensaje:", error.message);
        console.error("   - Detalles completos:", error);
      }

      return [];
    }
  }

  /**
   * Obtiene el ranking del usuario actual
   * @returns {Promise<Object|null>}
   */
  async getUserRanking() {
    try {
      // Verificaciones de seguridad mejoradas
      if (!this.isReady()) {
        console.warn("üî• FirebaseManager: Firebase no est√° listo para obtener ranking");
        return null;
      }

      if (!this.currentUser || this.currentUser.isAnonymous) {
        console.warn("üî• FirebaseManager: Usuario an√≥nimo no tiene ranking");
        return {
          rank: null,
          bestScore: 0,
          totalGames: 0,
          averageScore: 0,
          totalPlayTime: 0,
          userFound: false,
        };
      }

      console.log("üî• FirebaseManager: Obteniendo ranking de usuario...");
      const userId = this.currentUser.uid;

      // üéØ PASO 1: Obtener el mejor score del usuario de la nueva colecci√≥n
      let userBestScore = 0;
      let userScoreData = null;
      
      try {
        console.log("üî• FirebaseManager: Buscando mejor score del usuario...");
        const userScores = await this.db
          .collection("leaderboard_scores")
          .where("userId", "==", userId)
          .orderBy("score", "desc")
          .limit(1)
          .get();

        if (!userScores.empty) {
          userScoreData = userScores.docs[0].data();
          userBestScore = userScoreData.score;
          console.log(`üî• FirebaseManager: Mejor score encontrado: ${userBestScore}`);
        } else {
          console.log("üî• FirebaseManager: Usuario no tiene scores registrados");
          return {
            rank: null,
            bestScore: 0,
            totalGames: 0,
            averageScore: 0,
            totalPlayTime: 0,
            userFound: false,
          };
        }
      } catch (scoreError) {
        console.error("üî• FirebaseManager: Error obteniendo scores del usuario:", scoreError);
        throw scoreError;
      }

      // üéØ PASO 2: Contar cu√°ntos usuarios tienen mejor puntuaci√≥n (para calcular ranking)
      let rank = 1;
      try {
        console.log(`üî• FirebaseManager: Calculando ranking (scores > ${userBestScore})...`);
        const betterScores = await this.db
          .collection("leaderboard_scores")
          .where("score", ">", userBestScore)
          .get();

        rank = betterScores.size + 1;
        console.log(`üî• FirebaseManager: Posici√≥n en ranking: #${rank}`);
      } catch (rankError) {
        console.warn("üî• FirebaseManager: ‚ö†Ô∏è Error calculando ranking, usando posici√≥n 1:", rankError);
        rank = 1;
      }

      // üéØ PASO 3: Obtener estad√≠sticas personales de la nueva colecci√≥n user_stats
      let userStats = {
        totalGames: 1,
        averageScore: userBestScore,
        totalPlayTime: userScoreData?.gameTime || 0,
      };

      try {
        console.log("üî• FirebaseManager: Obteniendo estad√≠sticas personales...");
        const statsDoc = await this.db
          .collection("user_stats")
          .doc(userId)
          .get();

        if (statsDoc.exists) {
          const statsData = statsDoc.data();
          userStats = {
            totalGames: statsData.totalGames || 1,
            averageScore: statsData.averageScore || userBestScore,
            totalPlayTime: statsData.totalPlayTime || 0,
          };
          console.log("üî• FirebaseManager: ‚úÖ Estad√≠sticas personales obtenidas");
        } else {
          console.log("üî• FirebaseManager: No hay estad√≠sticas previas - usando valores por defecto");
        }
      } catch (statsError) {
        console.warn("üî• FirebaseManager: ‚ö†Ô∏è Error obteniendo estad√≠sticas, usando valores por defecto:", statsError);
      }

      const ranking = {
        rank: rank,
        bestScore: userBestScore,
        totalGames: userStats.totalGames,
        averageScore: userStats.averageScore,
        totalPlayTime: userStats.totalPlayTime,
        userFound: true,
        level: userScoreData?.level || 1,
        lastPlayed: userScoreData?.timestamp?.toDate?.() || null,
        nickname: userScoreData?.nickname || "Usuario",
      };

      console.log("üî• FirebaseManager: ‚úÖ Ranking de usuario completo:", ranking);
      return ranking;

    } catch (error) {
      console.error("üî• FirebaseManager: ‚ùå Error obteniendo ranking de usuario:", error);
      
      // Diagn√≥stico detallado mejorado
      if (error.code === "permission-denied") {
        console.error("üö® Error de permisos en getUserRanking - Verificar:");
        console.error("   - ¬øLas reglas permiten lectura de 'leaderboard_scores' y 'user_stats'?");
        console.error(`   - ¬øUsuario autenticado? ${!!this.currentUser}`);
        console.error(`   - ¬øUsuario an√≥nimo? ${this.currentUser?.isAnonymous}`);
        console.error(`   - UID del usuario: ${this.currentUser?.uid}`);
        console.error("   - Verifica que las reglas Firestore est√©n publicadas correctamente");
      } else if (error.message?.includes("index") || error.code === "failed-precondition") {
        console.error("üö® Error de √≠ndices - Verificar:");
        console.error("   1. √çndice necesario: leaderboard_scores ‚Üí userId (Ascending), score (Descending)");
        console.error("   2. Ve a Firebase Console ‚Üí Firestore ‚Üí Indexes");
        console.error("   3. Los √≠ndices pueden tardar unos minutos en estar disponibles");
      } else {
        console.error("   - C√≥digo de error:", error.code);
        console.error("   - Mensaje:", error.message);
      }
      
      return null;
    }
  }

  /**
   * Actualiza estad√≠sticas personales del usuario
   * @private
   */
  async updateUserPersonalStats(score, level, gameTime, gameStats) {
    try {
      if (
        !this.isReady() ||
        !this.currentUser ||
        this.currentUser.isAnonymous
      ) {
        return;
      }

      const userDoc = this.db.collection("users").doc(this.currentUser.uid);

      // Actualizar estad√≠sticas con incrementos at√≥micos
      await userDoc.set(
        {
          stats: {
            totalGames: firebase.firestore.FieldValue.increment(1),
            totalScore: firebase.firestore.FieldValue.increment(score),
            totalPlayTime: firebase.firestore.FieldValue.increment(
              Math.round(gameTime)
            ),
            totalJumps: firebase.firestore.FieldValue.increment(
              gameStats.totalJumps || 0
            ),
            lastPlayed: firebase.firestore.FieldValue.serverTimestamp(),
            lastScore: score,
            lastLevel: level,
          },
        },
        { merge: true }
      );

      console.log(
        "üî• FirebaseManager: ‚úÖ Estad√≠sticas personales actualizadas"
      );
    } catch (error) {
      console.warn(
        "üî• FirebaseManager: ‚ö†Ô∏è Error actualizando estad√≠sticas:",
        error
      );
    }
  }

  /**
   * Obtiene estad√≠sticas personales del usuario
   * @returns {Promise<Object|null>}
   */
  async getUserPersonalStats() {
    try {
      if (
        !this.isReady() ||
        !this.currentUser ||
        this.currentUser.isAnonymous
      ) {
        return null;
      }

      const userDoc = await this.db
        .collection("users")
        .doc(this.currentUser.uid)
        .get();

      if (userDoc.exists && userDoc.data().stats) {
        const stats = userDoc.data().stats;

        // Calcular promedio si hay juegos
        if (stats.totalGames > 0 && stats.totalScore) {
          stats.averageScore = Math.round(stats.totalScore / stats.totalGames);
        } else {
          stats.averageScore = 0;
        }

        console.log("üî• FirebaseManager: ‚úÖ Estad√≠sticas personales obtenidas");
        return stats;
      }

      return null;
    } catch (error) {
      console.error(
        "üî• FirebaseManager: ‚ùå Error obteniendo stats personales:",
        error
      );
      return null;
    }
  }

  /**
   * Obtiene informaci√≥n del navegador para metadatos
   * @private
   */
  getBrowserInfo() {
    const ua = navigator.userAgent;
    if (ua.includes("Chrome")) return "Chrome";
    if (ua.includes("Firefox")) return "Firefox";
    if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
    if (ua.includes("Edge")) return "Edge";
    return "Unknown";
  }

  /**
   * Detecta tipo de dispositivo
   * @private
   */
  getDeviceType() {
    if (/Mobile|Android|iPhone|iPad/.test(navigator.userAgent)) {
      return "mobile";
    }
    return "desktop";
  }

  /**
   * Obtiene leaderboard filtrado por per√≠odo de tiempo
   * @param {string} period - 'today', 'week', 'month', 'all'
   * @param {number} limit - N√∫mero m√°ximo de resultados
   * @returns {Promise<Array>}
   */
  async getLeaderboardByPeriod(period = "all", limit = 10) {
    try {
      if (!this.isReady()) {
        return [];
      }

      let query = this.db.collection("leaderboard_scores");

      // Calcular fecha l√≠mite seg√∫n el per√≠odo
      if (period !== "all") {
        const now = new Date();
        let startDate;

        switch (period) {
          case "today":
            startDate = new Date(
              now.getFullYear(),
              now.getMonth(),
              now.getDate()
            );
            break;
          case "week":
            startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            break;
          case "month":
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            break;
        }

        if (startDate) {
          query = query.where(
            "timestamp",
            ">=",
            firebase.firestore.Timestamp.fromDate(startDate)
          );
        }
      }

      const snapshot = await query
        .orderBy("score", "desc")
        .orderBy("timestamp", "asc")
        .limit(limit)
        .get();

      const leaderboard = snapshot.docs.map((doc, index) => {
        const data = doc.data();
        return {
          rank: index + 1,
          id: doc.id,
          nickname: data.nickname,
          score: data.score,
          level: data.level,
          gameTime: data.gameTime,
          timestamp: data.timestamp?.toDate?.() || null,
          isCurrentUser: data.userId === this.currentUser?.uid,
        };
      });

      console.log(
        `üî• FirebaseManager: ‚úÖ Leaderboard ${period} obtenido (${leaderboard.length} entradas)`
      );
      return leaderboard;
    } catch (error) {
      console.error(
        `üî• FirebaseManager: ‚ùå Error obteniendo leaderboard ${period}:`,
        error
      );
      return [];
    }
  }
}

// Verificar que no haya conflictos con otros managers
if (typeof window !== "undefined") {
  window.FirebaseManager = FirebaseManager;
}

console.log("üî• FirebaseManager: Clase definida correctamente");
